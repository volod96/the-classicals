'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by pubudud on 8/30/17.
 */

/**
 * This module does all the parsing and modifying the query tasks
 */
var QueryBuilder = function () {

    /**
     * Constructor
     */
    function QueryBuilder() {
        _classCallCheck(this, QueryBuilder);

        this.middleware = [];
    }

    /**
     * Save a middleware to be used before executing a query
     * @param {string} key - field of the options object that will be used to identify applicable middleware
     * @param {Object} middleware - actual query modifying middleware
     */


    _createClass(QueryBuilder, [{
        key: 'use',
        value: function use(key, middleware) {
            this.middleware.push({ key: key, middleware: middleware });
        }

        /**
         * Remove a middleware from the list using given key
         * @param {string} key - middleware key
         */

    }, {
        key: 'removeMiddleware',
        value: function removeMiddleware(key) {
            this.middleware = this.middleware.filter(function (middleware) {
                return middleware.key !== key;
            });
        }

        /**
         * Build merchant type check query suffix based on the dashboard and development values
         *
         * @param {Object} options - Same as the options object received by executeQuery method
         * @returns {object} - Processed QueryHandler and Args
         */

    }, {
        key: 'parseQuery',
        value: function parseQuery() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            // Parameter destructing
            var query = options.query;

            // If the query was not sent, we generate a new error

            if (!query) {
                var err = new Error('query cannot be undefined');
                err.appendDetails('QueryBuilder', 'parseQuery', 'QueryHandler is undefined');
                throw err;
            }

            var updatedOptions = this.applyMiddleware(options) || options;

            return { query: updatedOptions.query, args: updatedOptions.args };
        }

        /**
         * Use middleware as applicable
         * @param {Object} options - query execution configs
         * @returns {Object} <- updated options object
         */

    }, {
        key: 'applyMiddleware',
        value: function applyMiddleware(options) {
            return this.middleware.reduce(function (updatedOptions, _ref) {
                var key = _ref.key,
                    middleware = _ref.middleware;

                if (options[key]) {
                    return middleware(updatedOptions);
                }
                return updatedOptions;
            }, options);
        }
    }]);

    return QueryBuilder;
}();

exports.default = new QueryBuilder();