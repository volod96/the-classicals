'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by pubudud on 8/29/17.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _handler = require('./query/handler');

var _handler2 = _interopRequireDefault(_handler);

var _handler3 = require('./transaction/handler');

var _handler4 = _interopRequireDefault(_handler3);

var _constants = require('./constants');

var constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Proxy module which wraps node-mysql functionality
 */
var MysqlFacade = function () {
    function MysqlFacade() {
        _classCallCheck(this, MysqlFacade);
    }

    _createClass(MysqlFacade, [{
        key: 'execute',


        /**
         *
         * @param {string|null|Object} [query] - QueryHandler to be executed
         * @param {Array|Object} [args] - Arguments to the query if it is a prepared statement
         *
         * @param {object} options - options object
         *      @param {string} options.query - QueryHandler to be executed
         *      @param {Array} [options.args] - Arguments to the query if it is a prepared statement
         *      @param {string} [options.pool = DEFAULT]  - Mysql connection pool
         *      @param {boolean} [options.lengthConstraint] - Whether or not the group concat max length constraint should be applied
         *
         * @returns {Promise} <- Query result
         */
        value: function execute(query, args, options) {

            // Base Parameter validation
            if (!query && !args && !options) {
                var err = new Error('Invalid arguments received');
                err.appendDetails('MysqlFacade', 'execute', 'Invalid arguments received');
                return Promise.reject(err);
            }

            if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && !Array.isArray(args)) {
                options = args;
                args = null;
            }

            if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
                options = query;
                args = null;
                query = null;
            }

            options = _extends({}, options, {
                query: query || (options || {}).query,
                args: args || (options || {}).args
            });

            return _handler2.default.executeQuery(options);
        }

        /**
         * Execute a transaction with any given number of queries
         *
         * @param {Object} options - transaction options.
         *      @param {string} [options.pool] - Mysql connection pool type.
         *      @param {Object[]} options.queries - Object array of query and args pairs -> [{query: query, args:args}^n].
         *      @param {number} [options.queryCountThreshold] - Value to override the default TRANSACTION_QUERY_COUNT_THRESHOLD
         * @returns {Promise} - Transactions results as an object
         */

    }, {
        key: 'executeTransaction',
        value: function executeTransaction(options) {
            // Base Parameter validation
            if (!options) {
                var err = new Error('Invalid arguments received');
                err.appendDetails('TransactionHandler', 'executeTransaction', 'options:' + options);
                return Promise.reject(err);
            }

            var queries = options.queries;

            // If at least one query was not sent, we generate a new error
            if (!queries || !queries.length) {
                var _err = new Error('Queries parameter is undefined');
                _err.appendDetails('TransactionHandler', 'executeTransaction', 'Queries: ' + queries);
                return Promise.reject(_err);
            }

            // Currently allow maximum of 10 queries only.
            var QUERY_COUNT_THRESHOLD = options.queryCountThreshold || constants.TRANSACTION_QUERY_COUNT_THRESHOLD;

            // Check query count threshold
            // This is just an extra precaution. If test results doesn't show any issues, this constraint can be removed
            if (queries.length > QUERY_COUNT_THRESHOLD) {
                var _err2 = new Error('QueryHandler count exceeds threshold');
                _err2.appendDetails('TransactionHandler', 'executeTransaction', 'QueryHandler count exceeds threshold');
                return Promise.reject(_err2);
            }

            return _handler4.default.executeTransaction(options);
        }
    }]);

    return MysqlFacade;
}();

exports.default = new MysqlFacade();